
# Файлы, игнорируемые по умолчанию
/shelf/
/workspace.xml
# Environment-dependent path to Maven home directory
/mavenHomeManager.xml


<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AmplicodeJpaIdeaProjectConfig">
    <option name="defaultUnitInitialized" value="true" />
  </component>
</project>

<component name="ProjectCodeStyleConfiguration">
  <code_scheme name="Project" version="173">
    <ScalaCodeStyleSettings>
      <option name="MULTILINE_STRING_CLOSING_QUOTES_ON_NEW_LINE" value="true" />
    </ScalaCodeStyleSettings>
  </code_scheme>
</component>

<component name="ProjectCodeStyleConfiguration">
  <state>
    <option name="PREFERRED_PROJECT_CODE_STYLE" value="Default" />
  </state>
</component>

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CompilerConfiguration">
    <annotationProcessing>
      <profile name="Maven default annotation processors profile" enabled="true">
        <sourceOutputDir name="target/generated-sources/annotations" />
        <sourceTestOutputDir name="target/generated-test-sources/test-annotations" />
        <outputRelativeToContentRoot value="true" />
        <module name="olymp_schools" />
      </profile>
    </annotationProcessing>
  </component>
  <component name="JavacSettings">
    <option name="ADDITIONAL_OPTIONS_OVERRIDE">
      <module name="olymp_schools" options="-parameters" />
    </option>
  </component>
</project>

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="Encoding">
    <file url="file://$PROJECT_DIR$/src/main/java" charset="UTF-8" />
  </component>
</project>

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="RemoteRepositoriesConfiguration">
    <remote-repository>
      <option name="id" value="central" />
      <option name="name" value="Central Repository" />
      <option name="url" value="https://repo.maven.apache.org/maven2" />
    </remote-repository>
    <remote-repository>
      <option name="id" value="central" />
      <option name="name" value="Maven Central repository" />
      <option name="url" value="https://repo1.maven.org/maven2" />
    </remote-repository>
    <remote-repository>
      <option name="id" value="jboss.community" />
      <option name="name" value="JBoss Community repository" />
      <option name="url" value="https://repository.jboss.org/nexus/content/repositories/public/" />
    </remote-repository>
  </component>
</project>

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ExternalStorageConfigurationManager" enabled="true" />
  <component name="ProjectRootManager" version="2" default="true" />
</project>

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="$PROJECT_DIR$/.." vcs="Git" />
  </component>
</project>

<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="AutoImportSettings">
    <option name="autoReloadType" value="SELECTIVE" />
  </component>
  <component name="ChangeListManager">
    <list default="true" id="c4db8ff3-18b6-48f7-9ca9-6b9edaa12669" name="Изменения" comment="" />
    <option name="SHOW_DIALOG" value="false" />
    <option name="HIGHLIGHT_CONFLICTS" value="true" />
    <option name="HIGHLIGHT_NON_ACTIVE_CHANGELIST" value="false" />
    <option name="LAST_RESOLUTION" value="IGNORE" />
  </component>
  <component name="Git.Settings">
    <option name="RECENT_GIT_ROOT_PATH" value="$PROJECT_DIR$/.." />
  </component>
  <component name="GradleModuleStateConfig" initialized="true" />
  <component name="OpenIdeProjectLocalState">
    <option name="firstOpen" value="false" />
  </component>
  <component name="ProjectCodeStyleSettingsMigration">
    <option name="version" value="2" />
  </component>
  <component name="ProjectColorInfo"><![CDATA[{
  "customColor": "",
  "associatedIndex": 0
}]]></component>
  <component name="ProjectId" id="33TwQ75tUlBPy3g8y7Lm93gdt1C" />
  <component name="ProjectViewState">
    <option name="hideEmptyMiddlePackages" value="true" />
    <option name="showLibraryContents" value="true" />
  </component>
  <component name="PropertiesComponent"><![CDATA[{
  "keyToString": {
    "RunOnceActivity.ShowReadmeOnStart": "true",
    "RunOnceActivity.git.unshallow": "true",
    "git-widget-placeholder": "main",
    "last_opened_file_path": "/Users/admin/OpenideProjects/olymp_schools/backend"
  }
}]]></component>
  <component name="RunManager">
    <configuration name="NewsAppApplication" type="AmplicodeSpringBootApplication" nameIsGenerated="true">
      <option name="MAIN_CLASS_NAME" value="org.example.NewsAppApplication" />
      <module name="olymp_schools" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration default="true" type="JetRunConfigurationType">
      <module name="backend" />
      <method v="2">
        <option name="Make" enabled="true" />
      </method>
    </configuration>
    <configuration default="true" type="KotlinStandaloneScriptRunConfigurationType">
      <module name="backend" />
      <option name="filePath" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="PythonConfigurationType" factoryName="Python">
      <module name="backend" />
      <option name="ENV_FILES" value="" />
      <option name="INTERPRETER_OPTIONS" value="" />
      <option name="PARENT_ENVS" value="true" />
      <envs>
        <env name="PYTHONUNBUFFERED" value="1" />
      </envs>
      <option name="SDK_HOME" value="" />
      <option name="WORKING_DIRECTORY" value="" />
      <option name="IS_MODULE_SDK" value="false" />
      <option name="ADD_CONTENT_ROOTS" value="true" />
      <option name="ADD_SOURCE_ROOTS" value="true" />
      <option name="SCRIPT_NAME" value="" />
      <option name="PARAMETERS" value="" />
      <option name="SHOW_COMMAND_LINE" value="false" />
      <option name="EMULATE_TERMINAL" value="false" />
      <option name="MODULE_MODE" value="false" />
      <option name="REDIRECT_INPUT" value="false" />
      <option name="INPUT_FILE" value="" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="Tox" factoryName="Tox">
      <module name="backend" />
      <option name="ENV_FILES" value="" />
      <option name="INTERPRETER_OPTIONS" value="" />
      <option name="PARENT_ENVS" value="true" />
      <option name="SDK_HOME" value="" />
      <option name="WORKING_DIRECTORY" value="" />
      <option name="IS_MODULE_SDK" value="false" />
      <option name="ADD_CONTENT_ROOTS" value="true" />
      <option name="ADD_SOURCE_ROOTS" value="true" />
      <method v="2" />
    </configuration>
    <configuration default="true" type="ccruntests" factoryName="Run Study Tests">
      <module name="backend" />
      <option name="ENV_FILES" value="" />
      <option name="INTERPRETER_OPTIONS" value="" />
      <option name="PARENT_ENVS" value="true" />
      <envs>
        <env name="PYTHONUNBUFFERED" value="1" />
      </envs>
      <option name="SDK_HOME" value="" />
      <option name="WORKING_DIRECTORY" value="" />
      <option name="IS_MODULE_SDK" value="false" />
      <option name="ADD_CONTENT_ROOTS" value="true" />
      <option name="ADD_SOURCE_ROOTS" value="true" />
      <option name="SCRIPT_NAME" value="" />
      <option name="PARAMETERS" value="" />
      <option name="SHOW_COMMAND_LINE" value="false" />
      <option name="EMULATE_TERMINAL" value="false" />
      <option name="MODULE_MODE" value="false" />
      <option name="REDIRECT_INPUT" value="false" />
      <option name="INPUT_FILE" value="" />
      <option name="studyTest" value="" />
      <method v="2" />
    </configuration>
  </component>
  <component name="TaskManager">
    <task active="true" id="Default" summary="Задача по умолчанию">
      <changelist id="c4db8ff3-18b6-48f7-9ca9-6b9edaa12669" name="Изменения" comment="" />
      <created>1759354351220</created>
      <option name="number" value="Default" />
      <option name="presentableId" value="Default" />
      <updated>1759354351220</updated>
    </task>
    <servers />
  </component>
</project>

# Multi-stage Dockerfile

# Этап 1: Сборка приложения
FROM eclipse-temurin:22-jdk AS builder
WORKDIR /app

# Устанавливаем maven
RUN apt-get update && apt-get install -y maven

# Копируем pom и исходники
COPY pom.xml .
COPY src ./src

# Сборка с кешем для ~/.m2
RUN --mount=type=cache,target=/root/.m2 \
    mvn clean package -DskipTests

# Этап 2: Runtime-образ для продакшена
FROM eclipse-temurin:22-jre-alpine
WORKDIR /app

# Создаём пользователя для запуска приложения
RUN addgroup -g 1001 -S appgroup && \
    adduser -S appuser -u 1001 -G appgroup

# Создаем директории для SSL и загрузок
RUN mkdir -p /app/uploads /etc/ssl && \
    chown -R appuser:appgroup /app/uploads /etc/ssl

# Копируем собранный jar из builder stage
COPY --from=builder --chown=appuser:appgroup /app/target/*.jar app.jar

# Переключаемся на пользователя appuser
USER appuser

# Порт приложения
EXPOSE 8300

# Переменные окружения для JVM
ENV JAVA_OPTS=""

# Запуск приложения
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar /app/app.jar"]

<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>olymp_schools</artifactId>
    <version>1.0-SNAPSHOT</version>

        <parent>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-parent</artifactId>
            <version>3.2.0</version>
            <relativePath/>
        </parent>

        <properties>
            <maven.compiler.source>22</maven.compiler.source>
            <maven.compiler.target>22</maven.compiler.target>
            <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
        </properties>

        <dependencies>
            <!-- Spring Boot Web -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-web</artifactId>
            </dependency>
            <!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
            <dependency>
                <groupId>org.projectlombok</groupId>
                <artifactId>lombok</artifactId>
                <version>1.18.42</version>
            </dependency>
            <!-- SpringDoc OpenAPI для Swagger UI -->
            <dependency>
                <groupId>org.springdoc</groupId>
                <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
                <version>2.3.0</version>
            </dependency>
            <!-- Spring Boot Data JPA -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-data-jpa</artifactId>
            </dependency>
            <!-- PostgreSQL Driver -->
            <dependency>
                <groupId>org.postgresql</groupId>
                <artifactId>postgresql</artifactId>
                <scope>runtime</scope>
            </dependency>
            <!-- Spring Security -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-security</artifactId>
            </dependency>
            <!-- JWT -->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt-api</artifactId>
                <version>0.12.6</version>
            </dependency>
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt-impl</artifactId>
                <version>0.12.6</version>
                <scope>runtime</scope>
            </dependency>
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt-jackson</artifactId>
                <version>0.12.6</version>
                <scope>runtime</scope>
            </dependency>
            <!-- Validation -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-validation</artifactId>
            </dependency>
            <!-- BCrypt для паролей -->
            <dependency>
                <groupId>org.springframework.security</groupId>
                <artifactId>spring-security-crypto</artifactId>
            </dependency>
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-databind</artifactId>
                <version>2.15.2</version> <!-- Или новее -->
            </dependency>
            <!-- Apache POI for Excel -->
            <dependency>
                <groupId>org.apache.poi</groupId>
                <artifactId>poi-ooxml</artifactId>
                <version>5.2.5</version>
            </dependency>
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter-mail</artifactId>
            </dependency>
        </dependencies>

        <build>
            <plugins>
                <plugin>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                </plugin>
            </plugins>
        </build>

</project>

package org.example;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class NewsAppApplication {
    public static void main(String[] args) {
        SpringApplication.run(NewsAppApplication.class, args);
    }
}

package org.example.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

@Configuration
public class CorsConfig {

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        // Разрешаем все origins
        configuration.setAllowedOriginPatterns(Arrays.asList("*"));
        // Разрешаем все методы
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH", "HEAD"));
        // Разрешаем все заголовки
        configuration.setAllowedHeaders(Arrays.asList("*"));
        // Разрешаем credentials (куки, авторизацию)
        configuration.setAllowCredentials(true);
        // Устанавливаем максимальное время кеширования preflight запросов
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}

package org.example.config;

import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import io.swagger.v3.oas.models.security.SecurityScheme;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class OpenApiConfig {
    @Bean
    public OpenAPI customOpenAPI() {
        final String securitySchemeName = "bearerAuth";
        return new OpenAPI()
                .addSecurityItem(new SecurityRequirement().addList(securitySchemeName))
                .components(new Components()
                        .addSecuritySchemes(securitySchemeName,
                                new SecurityScheme()
                                        .name(securitySchemeName)
                                        .type(SecurityScheme.Type.HTTP)
                                        .scheme("bearer")
                                        .bearerFormat("JWT")));
    }
}

package org.example.config;

import org.example.security.JwtAuthenticationFilter;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfigurationSource;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;
    private final CorsConfigurationSource corsConfigurationSource;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter, CorsConfigurationSource corsConfigurationSource) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
        this.corsConfigurationSource = corsConfigurationSource;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
                .cors(cors -> cors.configurationSource(corsConfigurationSource))
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        // Swagger UI и OpenAPI - доступ для всех
                        .requestMatchers(
                                "/swagger-ui/**",
                                "/swagger-ui.html",
                                "/v3/api-docs/**",
                                "/swagger-resources/**",
                                "/webjars/**"
                        ).permitAll()

                        // публичные эндпоинты аутентификации
                        .requestMatchers("/api/auth/**").permitAll()

                        // публичный доступ к ресурсам приложения
                        .requestMatchers("/api/carousel/**", "/uploads/**").permitAll()
                        .requestMatchers("/api/news/**").permitAll()

                        // Админ-эндоинты
                        .requestMatchers("/api/admin/**").hasRole("ADMIN")

                        // остальные требуют аутентификации (JWT)
                        .anyRequest().authenticated()
                )
                .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();
    }
}

// src/main/java/org/example/config/WebConfig.java
package org.example.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Value("${upload.dir}")
    private String uploadDir;

    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        registry.addResourceHandler("/uploads/**")
                .addResourceLocations("file:" + uploadDir + "/");
    }
}

package org.example.controller;

import org.example.service.ImageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.io.IOException;
import java.util.List;

@RestController
@RequestMapping("/api/admin/carousel")
@Tag(name = "Admin Carousel", description = "Endpoints for admin carousel image management")
@PreAuthorize("hasRole('ADMIN')")
public class AdminCarouselController {
    private final ImageService imageService;

    public AdminCarouselController(ImageService imageService) {
        this.imageService = imageService;
    }

    @PostMapping(value = "/upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    @Operation(summary = "Upload images for carousel", description = "Upload one or multiple images")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Images uploaded"),
            @ApiResponse(responseCode = "400", description = "Invalid file")
    })
    public ResponseEntity<List<String>> uploadImages(
            @Parameter(description = "Files to upload", content = @Content(mediaType = MediaType.MULTIPART_FORM_DATA_VALUE, schema = @Schema(type = "string", format = "binary")))
            @RequestPart("files") List<MultipartFile> files) throws IOException {
        List<String> urls = imageService.uploadImages(files);
        return ResponseEntity.ok(urls);
    }

    @DeleteMapping("/{filename:.+}")
    @Operation(summary = "Delete carousel image", description = "Delete image by filename (only filename, not full path)")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Image deleted"),
            @ApiResponse(responseCode = "404", description = "Image not found")
    })
    public ResponseEntity<Void> deleteImage(
            @Parameter(description = "Filename only (e.g., c9f51d9b-e889-488c-a6b1-66f2b4f5b1ba.jpeg)", example = "c9f51d9b-e889-488c-a6b1-66f2b4f5b1ba.jpeg")
            @PathVariable String filename) throws IOException {
        imageService.deleteImage(filename);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/order")
    @Operation(summary = "Update image order", description = "Update the display order of carousel images")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Order updated successfully"),
            @ApiResponse(responseCode = "400", description = "Invalid order data")
    })
    public ResponseEntity<Void> updateImageOrder(
            @Parameter(description = "List of image URLs in new order")
            @RequestBody List<String> newOrder) throws IOException {
        imageService.updateImageOrder(newOrder);
        return ResponseEntity.ok().build();
    }
}

package org.example.controller;

import org.example.dto.AdminProfileResponse;
import org.example.dto.ProfileResponse;
import org.example.dto.OlympiadResponse;
import org.example.dto.ProfileUpdateRequest;
import org.example.entity.User;
import org.example.enums.Role;
import org.example.exception.EmailExistsException;
import org.example.exception.UserNotFoundException;
import org.example.service.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.core.io.ByteArrayResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/admin")
@Tag(name = "Admin", description = "Endpoints for admin role management")
@PreAuthorize("hasRole('ADMIN')")
public class AdminController {
    private final UserService userService;

    public AdminController(UserService userService) {
        this.userService = userService;
    }

    @PostMapping("/assign/{email}")
    public ResponseEntity<String> assignAdmin(@PathVariable String email) {
        userService.setRole(email, Role.ADMIN);
        return ResponseEntity.ok("ADMIN role assigned to " + email);
    }

    @PostMapping("/remove/{email}")
    public ResponseEntity<String> removeAdmin(@PathVariable String email) {
        userService.setRole(email, Role.USER);
        return ResponseEntity.ok("ADMIN role removed from " + email);
    }

    @GetMapping("/export-users")
    @Operation(summary = "Export user data to Excel with highlights", description = "Users without selected olympiads are highlighted in red, duplicates in yellow")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Excel file downloaded")
    })
    public ResponseEntity<ByteArrayResource> exportUsers() throws IOException {
        List<ProfileResponse> users = userService.getAllUserProfiles().stream()
        .sorted(java.util.Comparator.comparing(ProfileResponse::getId))
        .toList();

        // Находим дублирующиеся ФИО (нормализуем пробелы)
        Map<String, List<ProfileResponse>> fioGroups = users.stream()
                .collect(Collectors.groupingBy(user -> 
                    normalizeFio(user.getLastName()) + "|" +
                    normalizeFio(user.getFirstName()) + "|" +
                    normalizeFio(user.getMiddleName())
                ));

        Set<String> duplicateFios = fioGroups.entrySet().stream()
                .filter(entry -> entry.getValue().size() > 1)
                .map(Map.Entry::getKey)
                .collect(Collectors.toSet());

        Workbook workbook = new XSSFWorkbook();
        Sheet sheet = workbook.createSheet("Users");

        // Стили
        CellStyle headerStyle = workbook.createCellStyle();
        Font headerFont = workbook.createFont();
        headerFont.setBold(true);
        headerStyle.setFont(headerFont);
        headerStyle.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
        headerStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);

        // Желтый для дубликатов
        CellStyle duplicateStyle = workbook.createCellStyle();
        duplicateStyle.setFillForegroundColor(IndexedColors.YELLOW.getIndex());
        duplicateStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);

        // Красный для не определившихся с олимпиадой
        CellStyle highlightStyle = workbook.createCellStyle();
        highlightStyle.setFillForegroundColor(IndexedColors.RED.getIndex());
        highlightStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);

        // Заголовки
        Row headerRow = sheet.createRow(0);
        String[] headers = {
                "Дата", "№", "Фамилия", "Имя", "Отчество", "Дата рождения", "Пол",
                "СНИЛС", "Место жительства", "Тип населенного пункта", "Номер телефона", "e-mail",
                "Регион образовательной организации", "Наименование образовательной организации",
                "Класс/Курс", "Выбранные олимпиады"
        };

        for (int i = 0; i < headers.length; i++) {
            Cell cell = headerRow.createCell(i);
            cell.setCellValue(headers[i]);
            cell.setCellStyle(headerStyle);
        }

        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("dd.MM.yy");
        DateTimeFormatter birthDateFormatter = DateTimeFormatter.ofPattern("dd.MM.yyyy");

        int rowNum = 1;
        for (ProfileResponse user : users) {
            Row row = sheet.createRow(rowNum++);

            boolean hasOlympiads = user.getSelectedOlympiads() != null && !user.getSelectedOlympiads().isEmpty();
            
            // Проверяем, является ли запись дублирующейся по ФИО (нормализуем пробелы)
            String userFioKey = normalizeFio(user.getLastName()) + "|" +
                               normalizeFio(user.getFirstName()) + "|" +
                               normalizeFio(user.getMiddleName());
            boolean isDuplicate = duplicateFios.contains(userFioKey);

            CellStyle rowStyle = null;
            if (isDuplicate) {
                rowStyle = duplicateStyle; // Желтый для дубликатов
            } else if (!hasOlympiads) {
                rowStyle = highlightStyle; // Красный для не определившихся с олимпиадой
            }

            // Дата регистрации
            Cell cell0 = row.createCell(0);
            cell0.setCellValue(user.getRegistrationDate() != null ? user.getRegistrationDate().format(dateFormatter) : LocalDate.now().format(dateFormatter));
            if (rowStyle != null) cell0.setCellStyle(rowStyle);

            // ID вместо порядкового номера
            Cell cell1 = row.createCell(1);
            cell1.setCellValue(user.getId() != null ? user.getId().toString() : "");
            if (rowStyle != null) cell1.setCellStyle(rowStyle);

            // ФИО
            Cell cell2 = row.createCell(2);
            cell2.setCellValue(user.getLastName() != null ? user.getLastName() : "");
            Cell cell3 = row.createCell(3);
            cell3.setCellValue(user.getFirstName() != null ? user.getFirstName() : "");
            Cell cell4 = row.createCell(4);
            cell4.setCellValue(user.getMiddleName() != null ? user.getMiddleName() : "");
            if (rowStyle != null) { cell2.setCellStyle(rowStyle); cell3.setCellStyle(rowStyle); cell4.setCellStyle(rowStyle); }

            // Дата рождения
            Cell cell5 = row.createCell(5);
            cell5.setCellValue(user.getBirthDate() != null ? user.getBirthDate().format(birthDateFormatter) : "");
            if (rowStyle != null) cell5.setCellStyle(rowStyle);

            // Пол
            Cell cell6 = row.createCell(6);
            String genderStr = "";
            if (user.getGender() != null) {
                switch (user.getGender()) {
                    case MALE -> genderStr = "м";
                    case FEMALE -> genderStr = "ж";
                }
            }
            cell6.setCellValue(genderStr);
            if (rowStyle != null) cell6.setCellStyle(rowStyle);

            // СНИЛС
            Cell cell7 = row.createCell(7);
            cell7.setCellValue(user.getSnils() != null ? user.getSnils() : "");
            if (rowStyle != null) cell7.setCellStyle(rowStyle);

            // Место жительства
            Cell cell8 = row.createCell(8);
            StringBuilder residenceBuilder = new StringBuilder();
            if (user.getResidenceRegion() != null) {
                residenceBuilder.append(user.getResidenceRegion());
                if (user.getResidenceSettlement() != null) {
                    if (residenceBuilder.length() > 0) residenceBuilder.append(", ");
                    residenceBuilder.append(user.getResidenceSettlement());
                }
            }
            cell8.setCellValue(residenceBuilder.toString());
            if (rowStyle != null) cell8.setCellStyle(rowStyle);

            // Тип населенного пункта
            Cell cell9 = row.createCell(9);
            cell9.setCellValue(user.getSettlementType() != null ? user.getSettlementType() : "");
            if (rowStyle != null) cell9.setCellStyle(rowStyle);

            // Телефон и e-mail
            Cell cell10 = row.createCell(10);
            cell10.setCellValue(user.getPhoneNumber() != null ? user.getPhoneNumber() : "");
            Cell cell11 = row.createCell(11);
            cell11.setCellValue(user.getEmail() != null ? user.getEmail() : "");
            if (rowStyle != null) { cell10.setCellStyle(rowStyle); cell11.setCellStyle(rowStyle); }

            // Регион образовательной организации
            Cell cell12 = row.createCell(12);
            cell12.setCellValue(user.getResidenceRegion() != null ? user.getResidenceRegion() : "");
            if (rowStyle != null) cell12.setCellStyle(rowStyle);

            // Наименование образовательной организации
            Cell cell13 = row.createCell(13);
            cell13.setCellValue(user.getEducationalInstitution() != null ? user.getEducationalInstitution() : "");
            if (rowStyle != null) cell13.setCellStyle(rowStyle);

            // Класс/Курс
            Cell cell14 = row.createCell(14);
            cell14.setCellValue(user.getClassCourse() != null ? user.getClassCourse() : "");
            if (rowStyle != null) cell14.setCellStyle(rowStyle);


            // Выбранные олимпиады
            Cell cell17 = row.createCell(15);
            StringBuilder olympiadInfo = new StringBuilder();
            if (hasOlympiads) {
                for (OlympiadResponse olympiad : user.getSelectedOlympiads()) {
                    olympiadInfo.append(olympiad.getName());
                    if (olympiad.getDate() != null) {
                        olympiadInfo.append(" (").append(olympiad.getDate().format(dateFormatter)).append(")");
                    }
                    olympiadInfo.append("; ");
                }
                if (olympiadInfo.length() > 2) olympiadInfo.setLength(olympiadInfo.length() - 2);
            }
            cell17.setCellValue(olympiadInfo.toString());
            if (rowStyle != null) cell17.setCellStyle(rowStyle);
        }

        for (int i = 0; i < headers.length; i++) sheet.autoSizeColumn(i);

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        workbook.write(baos);
        workbook.close();
        byte[] bytes = baos.toByteArray();

        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=users_export_" + LocalDate.now() + ".xlsx")
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .body(new ByteArrayResource(bytes));
    }

    @GetMapping("/export-users-simple")
    @Operation(summary = "Export simplified user data to Excel with highlights", description = "Users without selected olympiads highlighted in red, duplicates in yellow")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Excel file downloaded")
    })
    public ResponseEntity<ByteArrayResource> exportUsersSimple() throws IOException {
        List<ProfileResponse> users = userService.getAllUserProfiles().stream()
        .sorted(java.util.Comparator.comparing(ProfileResponse::getId))
        .toList();

        // Находим дублирующиеся ФИО (нормализуем пробелы)
        Map<String, List<ProfileResponse>> fioGroups = users.stream()
                .collect(Collectors.groupingBy(user -> 
                    normalizeFio(user.getLastName()) + "|" +
                    normalizeFio(user.getFirstName()) + "|" +
                    normalizeFio(user.getMiddleName())
                ));

        Set<String> duplicateFios = fioGroups.entrySet().stream()
                .filter(entry -> entry.getValue().size() > 1)
                .map(Map.Entry::getKey)
                .collect(Collectors.toSet());

        Workbook workbook = new XSSFWorkbook();
        Sheet sheet = workbook.createSheet("Simple Users");

        CellStyle headerStyle = workbook.createCellStyle();
        Font headerFont = workbook.createFont();
        headerFont.setBold(true);
        headerStyle.setFont(headerFont);
        headerStyle.setFillForegroundColor(IndexedColors.GREY_25_PERCENT.getIndex());
        headerStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);

        // Желтый для дубликатов
        CellStyle duplicateStyle = workbook.createCellStyle();
        duplicateStyle.setFillForegroundColor(IndexedColors.YELLOW.getIndex());
        duplicateStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);

        // Красный для не определившихся с олимпиадой
        CellStyle highlightStyle = workbook.createCellStyle();
        highlightStyle.setFillForegroundColor(IndexedColors.RED.getIndex());
        highlightStyle.setFillPattern(FillPatternType.SOLID_FOREGROUND);

        String[] headers = {"Дата", "№", "Фамилия", "Имя", "Отчество", "Телефон", "e-mail", "Класс/Курс", "Выбранная Олимпиада"};
        Row headerRow = sheet.createRow(0);
        for (int i = 0; i < headers.length; i++) {
            Cell cell = headerRow.createCell(i);
            cell.setCellValue(headers[i]);
            cell.setCellStyle(headerStyle);
        }

        DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("dd.MM.yy");
        int rowNum = 1;
        for (ProfileResponse user : users) {
            Row row = sheet.createRow(rowNum++);
            boolean hasOlympiads = user.getSelectedOlympiads() != null && !user.getSelectedOlympiads().isEmpty();
            
            // Проверяем, является ли запись дублирующейся по ФИО (нормализуем пробелы)
            String userFioKey = normalizeFio(user.getLastName()) + "|" +
                               normalizeFio(user.getFirstName()) + "|" +
                               normalizeFio(user.getMiddleName());
            boolean isDuplicate = duplicateFios.contains(userFioKey);

            CellStyle rowStyle = null;
            if (isDuplicate) {
                rowStyle = duplicateStyle; // Желтый для дубликатов
            } else if (!hasOlympiads) {
                rowStyle = highlightStyle; // Красный для не определившихся с олимпиадой
            }

            // Дата
            Cell cell0 = row.createCell(0);
            cell0.setCellValue(user.getRegistrationDate() != null ? user.getRegistrationDate().format(dateFormatter) : LocalDate.now().format(dateFormatter));
            if (rowStyle != null) cell0.setCellStyle(rowStyle);

            // ID вместо порядкового номера
            Cell cell1 = row.createCell(1);
            cell1.setCellValue(user.getId() != null ? user.getId().toString() : "");
            if (rowStyle != null) cell1.setCellStyle(rowStyle);

            // ФИО
            Cell cell2 = row.createCell(2);
            cell2.setCellValue(user.getLastName() != null ? user.getLastName() : "");
            Cell cell3 = row.createCell(3);
            cell3.setCellValue(user.getFirstName() != null ? user.getFirstName() : "");
            Cell cell4 = row.createCell(4);
            cell4.setCellValue(user.getMiddleName() != null ? user.getMiddleName() : "");
            if (rowStyle != null) {
                cell2.setCellStyle(rowStyle);
                cell3.setCellStyle(rowStyle);
                cell4.setCellStyle(rowStyle);
            }

            // Телефон и e-mail
            Cell cell5 = row.createCell(5);
            cell5.setCellValue(user.getPhoneNumber() != null ? user.getPhoneNumber() : "");
            Cell cell6 = row.createCell(6);
            cell6.setCellValue(user.getEmail() != null ? user.getEmail() : "");
            if (rowStyle != null) {
                cell5.setCellStyle(rowStyle);
                cell6.setCellStyle(rowStyle);
            }

            // Класс/курс
            Cell cell7 = row.createCell(7);
            cell7.setCellValue(user.getClassCourse() != null ? user.getClassCourse() : "");
            if (rowStyle != null) cell7.setCellStyle(rowStyle);

            // Выбранная Олимпиада
            Cell cell8 = row.createCell(8);
            StringBuilder olympiads = new StringBuilder();
            if (hasOlympiads) {
                for (OlympiadResponse olympiad : user.getSelectedOlympiads()) {
                    olympiads.append(olympiad.getName());
                    if (olympiad.getDate() != null) {
                        olympiads.append(" (").append(olympiad.getDate().format(dateFormatter)).append(")");
                    }
                    olympiads.append("; ");
                }
                if (olympiads.length() > 2) olympiads.setLength(olympiads.length() - 2);
            }
            cell8.setCellValue(olympiads.toString());
            if (rowStyle != null) cell8.setCellStyle(rowStyle);
        }

        for (int i = 0; i < headers.length; i++) sheet.autoSizeColumn(i);

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        workbook.write(baos);
        workbook.close();

        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=users_simple_export_" + LocalDate.now() + ".xlsx")
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .body(new ByteArrayResource(baos.toByteArray()));
    }

    // Вспомогательный метод для нормализации ФИО (удаление пробелов в начале и конце)
    private String normalizeFio(String fio) {
        if (fio == null) {
            return "";
        }
        return fio.trim();
    }

    @DeleteMapping("/user/{email}")
    @Operation(summary = "Delete user by email", description = "Permanently delete user and their olympiad selections")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "User deleted successfully"),
        @ApiResponse(responseCode = "404", description = "User not found")
    })
    public ResponseEntity<String> deleteUser(@PathVariable String email) {
        try {
            userService.deleteUserByEmail(email);
            return ResponseEntity.ok("User with email " + email + " deleted successfully");
        } catch (UserNotFoundException e) {
            return ResponseEntity.status(404).body(e.getMessage());
        }
    }

    @GetMapping("/user/{email}")
    @Operation(summary = "Get user data by email", description = "Get user data in format compatible with update request")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "User data retrieved"),
        @ApiResponse(responseCode = "404", description = "User not found")
    })
    public ResponseEntity<AdminProfileResponse> getUserData(@PathVariable String email) {
        try {
            AdminProfileResponse userProfile = userService.getAdminProfileByEmail(email);
            return ResponseEntity.ok(userProfile);
        } catch (UserNotFoundException e) {
            return ResponseEntity.notFound().build();
        }
    }

    @PutMapping("/user/{email}")
    @Operation(summary = "Update user data by email", description = "Update user information including email change")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "User data updated"),
        @ApiResponse(responseCode = "404", description = "User not found"),
        @ApiResponse(responseCode = "400", description = "Invalid data or email exists")
    })
    public ResponseEntity<AdminProfileResponse> updateUserData(
            @PathVariable String email,
            @RequestBody ProfileUpdateRequest updateRequest) {
        try {
            User updatedUser = userService.updateUserProfileByAdmin(email, updateRequest);
            AdminProfileResponse updatedProfile = userService.getAdminProfileByEmail(updatedUser.getEmail());
            return ResponseEntity.ok(updatedProfile);
        } catch (UserNotFoundException e) {
            return ResponseEntity.notFound().build();
        } catch (EmailExistsException e) {
            return ResponseEntity.badRequest().build();
        }
    }
}

package org.example.controller;

import org.example.dto.CreateNewsRequest;
import org.example.dto.NewsResponse;
import org.example.service.NewsService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/admin/news")
@Tag(name = "Admin News", description = "Endpoints for admin news management")
@PreAuthorize("hasRole('ADMIN')")
public class AdminNewsController {
    private final NewsService newsService;

    public AdminNewsController(NewsService newsService) {
        this.newsService = newsService;
    }

    @PostMapping
    @Operation(summary = "Create news", description = "Create a new news item")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "News created"),
            @ApiResponse(responseCode = "400", description = "Invalid input")
    })
    public ResponseEntity<NewsResponse> createNews(@Valid @RequestBody CreateNewsRequest request) {
        NewsResponse response = newsService.createNews(request);
        return ResponseEntity.ok(response);
    }

    @DeleteMapping("/{id}")
    @Operation(summary = "Delete news", description = "Delete news by ID")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "News deleted"),
            @ApiResponse(responseCode = "404", description = "News not found")
    })
    public ResponseEntity<Void> deleteNews(@PathVariable Long id) {
        newsService.deleteNews(id);
        return ResponseEntity.noContent().build();
    }
}

package org.example.controller;

import org.example.dto.AddOlympiadRequest;
import org.example.entity.Olympiad;
import org.example.service.OlympiadService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/admin/olympiads")
@Tag(name = "Admin Olympiads", description = "Endpoints for admin olympiad management")
@PreAuthorize("hasRole('ADMIN')")
public class AdminOlympiadController {
    private final OlympiadService olympiadService;

    public AdminOlympiadController(OlympiadService olympiadService) {
        this.olympiadService = olympiadService;
    }

    @PostMapping
    @Operation(summary = "Add new olympiad", description = "Create a new olympiad by name, date and description")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Olympiad added"),
            @ApiResponse(responseCode = "400", description = "Olympiad already exists")
    })
    public ResponseEntity<Olympiad> addOlympiad(@RequestBody AddOlympiadRequest request) {
        Olympiad olympiad = olympiadService.create(request.getName(), request.getDate(), request.getDescription());
        return ResponseEntity.ok(olympiad);
    }

    @DeleteMapping("/{name}")
    @Operation(summary = "Delete olympiad", description = "Remove olympiad by name")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "204", description = "Olympiad deleted"),
            @ApiResponse(responseCode = "404", description = "Olympiad not found")
    })
    public ResponseEntity<Void> deleteOlympiad(@PathVariable String name) {
        olympiadService.deleteByName(name);
        return ResponseEntity.noContent().build();
    }
}

package org.example.controller;

import org.example.dto.*;
import org.example.entity.User;
import org.example.service.PasswordResetService;
import org.example.service.UserService;
import org.example.util.JwtUtil;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/auth")
@Tag(name = "Authentication", description = "Endpoints for user registration, login, logout and password reset")
public class AuthController {
    private final UserService userService;
    private final JwtUtil jwtUtil;
    private final PasswordResetService passwordResetService;

    public AuthController(UserService userService, JwtUtil jwtUtil, PasswordResetService passwordResetService) {
        this.userService = userService;
        this.jwtUtil = jwtUtil;
        this.passwordResetService = passwordResetService;
    }

    @PostMapping("/register")
    @Operation(summary = "Register new user", description = "Create a new user account and automatically login")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "User registered and logged in successfully"),
            @ApiResponse(responseCode = "400", description = "Invalid input or email exists")
    })
    public ResponseEntity<LoginResponse> register(@Valid @RequestBody RegisterRequest request) {
        User user = userService.register(request);
        String token = jwtUtil.generateToken(user.getEmail(), user.getRole());

        LoginResponse response = new LoginResponse();
        response.setToken(token);
        response.setMessage("Registration successful and automatically logged in");
        response.setRole(user.getRole());

        return ResponseEntity.ok(response);
    }

    @PostMapping("/login")
    @Operation(summary = "Login user", description = "Authenticate user and return JWT token with user role")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Login successful"),
            @ApiResponse(responseCode = "400", description = "Invalid credentials")
    })
    public ResponseEntity<LoginResponse> login(@Valid @RequestBody LoginRequest request) {
        User user = userService.findByEmail(request.getEmail());
        if (!userService.validatePassword(request.getPassword(), user.getPassword())) {
            LoginResponse errorResponse = new LoginResponse();
            errorResponse.setMessage("Invalid credentials");
            return ResponseEntity.badRequest().body(errorResponse);
        }

        String token = jwtUtil.generateToken(user.getEmail(), user.getRole());
        LoginResponse response = new LoginResponse();
        response.setToken(token);
        response.setMessage("Login successful");
        response.setRole(user.getRole());

        return ResponseEntity.ok(response);
    }

    @PostMapping("/logout")
    @Operation(summary = "Logout user", description = "Invalidate session (client-side)")
    @PreAuthorize("isAuthenticated()")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Logged out successfully")
    })
    public ResponseEntity<String> logout() {
        return ResponseEntity.ok("Logged out successfully");
    }

    @PostMapping("/forgot-password")
    @Operation(summary = "Request password reset", description = "Send password reset link to email")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Reset link sent successfully"),
            @ApiResponse(responseCode = "404", description = "User not found")
    })
    public ResponseEntity<String> forgotPassword(@Valid @RequestBody ForgotPasswordRequest request) {
        passwordResetService.initiatePasswordReset(request.getEmail());
        return ResponseEntity.ok("Ссылка для восстановления пароля отправлена на ваш email");
    }

    @PostMapping("/reset-password")
    @Operation(summary = "Reset password", description = "Reset password using reset token")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Password reset successfully"),
            @ApiResponse(responseCode = "400", description = "Invalid or expired token")
    })
    public ResponseEntity<ResetPasswordResponse> resetPassword(@Valid @RequestBody ResetPasswordRequest request) {
        ResetPasswordResponse response = passwordResetService.resetPassword(request.getToken(), request.getNewPassword());
        return ResponseEntity.ok(response);
    }

    @GetMapping("/validate-reset-token/{token}")
    @Operation(summary = "Validate reset token", description = "Check if password reset token is valid")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Token is valid"),
            @ApiResponse(responseCode = "400", description = "Token is invalid or expired")
    })
    public ResponseEntity<ResetPasswordResponse> validateResetToken(@PathVariable String token) {
        boolean isValid = passwordResetService.validateToken(token);
        if (isValid) {
            return ResponseEntity.ok(new ResetPasswordResponse("Токен действителен", true));
        } else {
            return ResponseEntity.badRequest().body(new ResetPasswordResponse("Неверный или просроченный токен", false));
        }
    }
}

package org.example.controller;

import org.example.service.ImageService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.io.IOException;
import java.util.List;

@RestController
@RequestMapping("/api/carousel")
@Tag(name = "Carousel", description = "Endpoints for carousel images")
public class CarouselController {
    private final ImageService imageService;

    public CarouselController(ImageService imageService) {
        this.imageService = imageService;
    }

    @GetMapping("/images")
    @Operation(summary = "Get all carousel image URLs", description = "Retrieve list of URLs for all uploaded images. Use only the filename (after last '/') for deletion.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Images retrieved")
    })
    public ResponseEntity<List<String>> getAllImages() throws IOException {
        List<String> urls = imageService.getAllImageUrls();
        return ResponseEntity.ok(urls);
    }
}

package org.example.controller;

import org.example.dto.NewsResponse;
import org.example.service.NewsService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/news")
@Tag(name = "News", description = "Endpoints for news")
public class NewsController {
    private final NewsService newsService;

    public NewsController(NewsService newsService) {
        this.newsService = newsService;
    }

    @GetMapping
    @Operation(summary = "Get all news", description = "Retrieve all news sorted by date (newest first)")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "News retrieved")
    })
    public ResponseEntity<List<NewsResponse>> getAllNews() {
        List<NewsResponse> news = newsService.getAllNews();
        return ResponseEntity.ok(news);
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get news by ID", description = "Retrieve specific news by ID")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "News found"),
            @ApiResponse(responseCode = "404", description = "News not found")
    })
    public ResponseEntity<NewsResponse> getNewsById(@PathVariable Long id) {
        NewsResponse news = newsService.getNewsById(id);
        return ResponseEntity.ok(news);
    }
}

package org.example.controller;

import org.example.dto.OlympiadResponse;
import org.example.entity.Olympiad;
import org.example.service.OlympiadService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/olympiads")
@Tag(name = "Olympiads", description = "Endpoints for managing available olympiads")
public class OlympiadController {
    private final OlympiadService olympiadService;

    public OlympiadController(OlympiadService olympiadService) {
        this.olympiadService = olympiadService;
    }

    @GetMapping
    @Operation(summary = "Get all available olympiads", description = "Retrieve list of all olympiads with names, dates and descriptions")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Olympiads retrieved")
    })
    public ResponseEntity<List<OlympiadResponse>> getAllOlympiads() {
        List<OlympiadResponse> responses = olympiadService.getAll().stream().map(o -> {
            OlympiadResponse r = new OlympiadResponse();
            r.setName(o.getName());
            r.setDate(o.getDate());
            r.setDescription(o.getDescription()); // Добавлено описание
            return r;
        }).collect(Collectors.toList());
        return ResponseEntity.ok(responses);
    }
}

package org.example.controller;

import org.example.dto.ProfileResponse;
import org.example.dto.ProfileUpdateRequest;
import org.example.entity.User;
import org.example.exception.UserNotFoundException;
import org.example.service.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/profile")
@Tag(name = "Profile", description = "Endpoints for user profile management")
@PreAuthorize("isAuthenticated()")
public class ProfileController {
    private final UserService userService;

    public ProfileController(UserService userService) {
        this.userService = userService;
    }

    @GetMapping
    @Operation(summary = "Get current user profile", description = "Retrieve decrypted profile information")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Profile retrieved"),
            @ApiResponse(responseCode = "404", description = "User not found")
    })
    public ResponseEntity<ProfileResponse> getProfile(Authentication authentication) {
        String email = authentication.getName();
        ProfileResponse profile = userService.getProfileByEmail(email);
        return ResponseEntity.ok(profile);
    }

    @PutMapping
    @Operation(summary = "Update current user profile", description = "Update profile data (partial update)")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Profile updated"),
            @ApiResponse(responseCode = "400", description = "Validation error or email exists"),
            @ApiResponse(responseCode = "404", description = "User not found")
    })
    public ResponseEntity<ProfileResponse> updateProfile(Authentication authentication,
                                                         @Valid @RequestBody ProfileUpdateRequest request) {
        String email = authentication.getName();
        User updatedUser = userService.updateProfile(email, request);
        ProfileResponse profile = userService.getProfileByEmail(updatedUser.getEmail());
        return ResponseEntity.ok(profile);
    }

    @PostMapping("/olympiads/select")
    @Operation(summary = "Select olympiads", description = "Assign olympiads to current user (array of olympiad names)")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Olympiads selected"),
            @ApiResponse(responseCode = "404", description = "Olympiad not found")
    })
    public ResponseEntity<String> selectOlympiads(Authentication authentication, @RequestBody List<String> olympiadNames) {
        String email = authentication.getName();
        userService.addOlympiads(email, olympiadNames);
        return ResponseEntity.ok("Olympiads selected successfully");
    }

    @DeleteMapping("/olympiads/{name}")
    @Operation(summary = "Remove olympiad", description = "Remove selected olympiad from current user")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Olympiad removed"),
            @ApiResponse(responseCode = "404", description = "Olympiad not found")
    })
    public ResponseEntity<String> removeOlympiad(Authentication authentication, @PathVariable String name) {
        String email = authentication.getName();
        userService.removeOlympiad(email, name);
        return ResponseEntity.ok("Olympiad removed successfully");
    }
}

package org.example.dto;

import lombok.Data;
import java.time.LocalDate;

@Data
public class AddOlympiadRequest {
    private String name;
    private LocalDate date;
    private String description; // Добавлено новое поле
}

package org.example.dto;

import org.example.enums.Gender;
import lombok.Data;

import java.time.LocalDate;
import java.util.List;

@Data
public class AdminProfileResponse {
    private String email;
    private String lastName;
    private String firstName;
    private String middleName;
    private LocalDate birthDate;
    private Gender gender;
    private String classCourse;
    private String educationalInstitution;
    private String institutionAddress;
    private String phoneNumber;
    private String residenceRegion;
    private String residenceSettlement;
    private String snils;
    private String postalAddress;
    
    // Добавляем поле для выбранных олимпиад (только для информации)
    private List<OlympiadResponse> selectedOlympiads;
}

package org.example.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

import java.time.LocalDate;

@Data
public class CreateNewsRequest {
    @NotBlank(message = "Title is required")
    private String title;

    @NotBlank(message = "Description is required")
    private String description;

    @NotNull(message = "News date is required")
    private LocalDate newsDate;
}

package org.example.dto;

import lombok.Data;

@Data
public class ErrorResponse {
    private String code;
    private String message;
}

package org.example.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class ForgotPasswordRequest {
    @Email
    @NotBlank
    private String email;
}

package org.example.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class LoginRequest {
    @Email
    @NotBlank
    private String email;

    @NotBlank
    private String password;
}

package org.example.dto;

import lombok.Data;
import org.example.enums.Role;

@Data
public class LoginResponse {
    private String token;
    private String message;
    private Role role; // Добавлено поле роли

    // Конструктор по умолчанию для случаев ошибок
    public LoginResponse() {
    }

    public LoginResponse(String token, String message, Role role) {
        this.token = token;
        this.message = message;
        this.role = role;
    }
}

package org.example.dto;

import lombok.Data;

import java.time.LocalDate;

@Data
public class NewsResponse {
    private Long id;
    private String title;
    private String description;
    private LocalDate newsDate;
    private LocalDate createdAt;
}

package org.example.dto;

import lombok.Data;
import java.time.LocalDate;

@Data
public class OlympiadResponse {
    private String name;
    private LocalDate date;
    private String description; // Добавлено новое поле
}

package org.example.dto;

import org.example.enums.Gender;
import org.example.enums.Role;
import lombok.Data;

import java.time.LocalDate;
import java.util.List;

@Data
public class ProfileResponse {
    private Long id;
    private String email;
    private Role role;

    // Дешифрованные персональные данные
    private String lastName;
    private String firstName;
    private String middleName;
    private LocalDate birthDate;
    private Gender gender;
    private String classCourse;
    private String educationalInstitution;
    private String institutionAddress;
    private String phoneNumber;
    private String residenceRegion;
    private String residenceSettlement;
    private String settlementType;
    private String snils;
    private String postalAddress;

    private LocalDate registrationDate;

    private List<OlympiadResponse> selectedOlympiads;
}

package org.example.dto;

import org.example.enums.Gender;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

import java.time.LocalDate;

@Data
public class ProfileUpdateRequest {
    private String email;  // Опционально, но уникально

    // Опциональные персональные (валидация только если переданы)
    private String lastName;
    private String firstName;
    private String middleName;
    private LocalDate birthDate;
    private Gender gender;
    private String classCourse;
    private String educationalInstitution;
    private String institutionAddress;
    private String phoneNumber;
    private String residenceRegion;
    private String residenceSettlement;
    private String snils;
    private String postalAddress;
}

package org.example.dto;

import org.example.enums.Gender;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

import java.time.LocalDate;

@Data
public class RegisterRequest {
    @Email
    @NotBlank
    private String email;

    @NotBlank
    private String password;

    @NotBlank
    private String lastName;

    @NotBlank
    private String firstName;

    private String middleName;

    @NotNull
    private LocalDate birthDate;

    @NotNull
    private Gender gender;

    private String classCourse;

    @NotBlank
    private String educationalInstitution;

    @NotBlank
    private String institutionAddress;

    @NotBlank
    private String phoneNumber;

    @NotBlank
    private String residenceRegion;

    @NotBlank
    private String residenceSettlement;
    
    private String settlementType;

    @NotBlank
    private String snils;

    @NotBlank
    private String postalAddress;
}

package org.example.dto;

import jakarta.validation.constraints.NotBlank;
import lombok.Data;

@Data
public class ResetPasswordRequest {
    @NotBlank
    private String token;

    @NotBlank
    private String newPassword;
}

package org.example.dto;

import lombok.Data;

@Data
public class ResetPasswordResponse {
    private String message;
    private boolean success;

    public ResetPasswordResponse() {}

    public ResetPasswordResponse(String message, boolean success) {
        this.message = message;
        this.success = success;
    }
}

package org.example.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;

import java.time.LocalDate;

@Entity
@Table(name = "news")
@Data
public class News {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    @NotBlank
    private String title;

    @Column(columnDefinition = "TEXT", nullable = false)
    @NotBlank
    private String description;

    @Column(nullable = false)
    @NotNull
    private LocalDate newsDate;

    @Column(nullable = false)
    private LocalDate createdAt;

    @PrePersist
    protected void onCreate() {
        createdAt = LocalDate.now();
    }
}

package org.example.entity;

import jakarta.persistence.*;
import lombok.Data;
import java.time.LocalDate;

@Entity
@Table(name = "olympiads")
@Data
public class Olympiad {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String name;

    @Column(nullable = false)
    private LocalDate date;

    @Column(columnDefinition = "TEXT")
    private String description; // Добавлено новое поле
}

package org.example.entity;

import jakarta.persistence.*;
import lombok.Data;

import java.time.LocalDateTime;

@Entity
@Table(name = "password_reset_tokens")
@Data
public class PasswordResetToken {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String token;

    @OneToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    private User user;

    @Column(nullable = false)
    private LocalDateTime expiryDate;

    @Column(nullable = false)
    private Boolean used = false;

    public boolean isExpired() {
        return LocalDateTime.now().isAfter(expiryDate);
    }
}

package org.example.entity;

import org.example.enums.Gender;
import org.example.enums.Role;  // Добавь импорт
import jakarta.persistence.*;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.Data;
import org.hibernate.annotations.ColumnTransformer;

import java.time.LocalDate;
import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "users")
@Data
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    @Email
    private String email;

    @Column(nullable = false)
    private String password;  // Хэшированный BCrypt

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private Role role = Role.USER;

    @Column
    private String lastName;  // Encrypted

    @Column
    private String firstName; // Encrypted

    @Column
    private String middleName; // Encrypted

    @Column
    @NotNull
    private LocalDate birthDate;

    @Enumerated(EnumType.STRING)
    @NotNull
    private Gender gender;

    @Column
    private String classCourse;

    @Column
    private String educationalInstitution;

    @Column
    private String institutionAddress; // Encrypted

    @Column
    private String phoneNumber; // Encrypted

    @Column
    private String residenceRegion; // Encrypted

    @Column
    private String residenceSettlement; // Encrypted

    @Column
    private String settlementType; // Тип населенного пункта

    @Column
    private String snils; // Encrypted

    @Column
    private String postalAddress; // Encrypted

    @Column(nullable = false)
    private LocalDate registrationDate;

    @PrePersist
    protected void onCreate() {
        registrationDate = LocalDate.now();
    }

    @ManyToMany
    @JoinTable(
            name = "user_olympiads",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "olympiad_id")
    )
    private Set<Olympiad> olympiads = new HashSet<>();
}

package org.example.enums;

public enum Gender {
    MALE, FEMALE
}

package org.example.enums;

public enum Role {
    ADMIN, USER
}

package org.example.exception;

public class EmailExistsException extends RuntimeException {
    public EmailExistsException(String message) {
        super(message);
    }
}

package org.example.exception;

import org.example.dto.ErrorResponse;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ErrorResponse> handleValidationExceptions(MethodArgumentNotValidException ex) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        ErrorResponse response = new ErrorResponse();
        response.setCode("VALIDATION_ERROR");
        response.setMessage("Validation failed: " + errors.toString());
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler({EmailExistsException.class, UserNotFoundException.class})
    public ResponseEntity<ErrorResponse> handleUserExceptions(RuntimeException ex) {
        ErrorResponse response = new ErrorResponse();
        response.setCode(ex.getClass().getSimpleName());
        response.setMessage(ex.getMessage());
        HttpStatus status = ex instanceof UserNotFoundException ? HttpStatus.NOT_FOUND : HttpStatus.BAD_REQUEST;
        return new ResponseEntity<>(response, status);
    }

    @ExceptionHandler(OlympiadNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleOlympiadNotFound(OlympiadNotFoundException ex) {
        ErrorResponse response = new ErrorResponse();
        response.setCode("OLYMPIAD_NOT_FOUND");
        response.setMessage(ex.getMessage());
        return new ResponseEntity<>(response, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(IOException.class)
    public ResponseEntity<ErrorResponse> handleIOException(IOException ex) {
        ErrorResponse response = new ErrorResponse();
        response.setCode("IO_ERROR");
        response.setMessage(ex.getMessage());
        return new ResponseEntity<>(response, HttpStatus.BAD_REQUEST);
    }

    // Добавьте обработку исключений для восстановления пароля
    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<ErrorResponse> handleRuntimeException(RuntimeException ex) {
        // Логгируем в консоль
        ex.printStackTrace();
        ErrorResponse response = new ErrorResponse();
        response.setCode("INTERNAL_ERROR");
        response.setMessage("An unexpected error occurred: " + ex.getMessage());
        return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {
        ex.printStackTrace();
        ErrorResponse response = new ErrorResponse();
        response.setCode("GENERIC_ERROR");
        response.setMessage("Server error: " + ex.getMessage());
        return new ResponseEntity<>(response, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex) {
        ErrorResponse response = new ErrorResponse();
        response.setCode("UNAUTHORIZED");
        response.setMessage("User not authenticated: " + ex.getMessage());
        return new ResponseEntity<>(response, HttpStatus.UNAUTHORIZED);
    }
}

package org.example.exception;

public class NewsNotFoundException extends RuntimeException {
    public NewsNotFoundException(String message) {
        super(message);
    }
}

// src/main/java/org/example/exception/OlympiadNotFoundException.java
package org.example.exception;

public class OlympiadNotFoundException extends RuntimeException {
    public OlympiadNotFoundException(String message) {
        super(message);
    }
}

package org.example.exception;

public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}

package org.example.repository;

import org.example.entity.News;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface NewsRepository extends JpaRepository<News, Long> {

    @Query("SELECT n FROM News n ORDER BY n.newsDate DESC, n.createdAt DESC")
    List<News> findAllOrderByDateDesc();

    List<News> findByOrderByNewsDateDescCreatedAtDesc();
}

// src/main/java/org/example/repository/OlympiadRepository.java
package org.example.repository;

import org.example.entity.Olympiad;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface OlympiadRepository extends JpaRepository<Olympiad, Long> {
    Optional<Olympiad> findByName(String name);

    @Modifying
    @Query(value = "DELETE FROM user_olympiads WHERE olympiad_id = ?1", nativeQuery = true)
    void deleteRelationsByOlympiadId(Long olympiadId);
}

package org.example.repository;

import org.example.entity.PasswordResetToken;
import org.example.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface PasswordResetTokenRepository extends JpaRepository<PasswordResetToken, Long> {
    Optional<PasswordResetToken> findByToken(String token);
    Optional<PasswordResetToken> findByUserAndUsedFalse(User user);

    @Modifying
    @Query("DELETE FROM PasswordResetToken t WHERE t.expiryDate < CURRENT_TIMESTAMP")
    void deleteExpiredTokens();

    @Modifying
    @Query("UPDATE PasswordResetToken t SET t.used = true WHERE t.user = ?1")
    void markAllTokensAsUsed(User user);
}

package org.example.repository;

import org.example.entity.User;
import org.example.enums.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmail(String email);
    long countByRole(Role role);
}

package org.example.security;

import org.example.service.UserService;
import org.example.util.JwtUtil;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtUtil jwtUtil;
    private final UserService userService;

    public JwtAuthenticationFilter(JwtUtil jwtUtil, UserService userService) {
        this.jwtUtil = jwtUtil;
        this.userService = userService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {
        String header = request.getHeader("Authorization");
        if (header != null && header.startsWith("Bearer ")) {
            String token = header.substring(7);
            String email = jwtUtil.extractEmail(token);
            if (email != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                UserDetails userDetails = userService.loadUserByUsername(email);
                UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());
                auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(auth);
            }
        }
        filterChain.doFilter(request, response);
    }
}

package org.example.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.mail.SimpleMailMessage;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.stereotype.Service;
import java.net.IDN;

@Service
public class EmailService {

    @Autowired
    private JavaMailSender mailSender;

    @Value("${spring.mail.username}")
    private String fromEmail;

    @Value("${app.frontend.url:http://localhost:3000}")
    private String frontendUrl;

    private String getPunycodeDomain(String url) {
        try {
            // Извлекаем протокол и домен
            String protocol = url.substring(0, url.indexOf("://") + 3);
            String domain = url.substring(url.indexOf("://") + 3);
            
            // Конвертируем домен в Punycode
            String punycode = IDN.toASCII(domain);
            
            return protocol + punycode;
        } catch (Exception e) {
            return url; // В случае ошибки возвращаем исходный URL
        }
    }

    public void sendPasswordResetEmail(String toEmail, String token) {
        try {
            String punycodeDomain = getPunycodeDomain(frontendUrl);
            String resetLink = punycodeDomain + "/reset-password?token=" + token;

            SimpleMailMessage message = new SimpleMailMessage();
            message.setFrom(fromEmail);
            message.setTo(toEmail);
            message.setSubject("Восстановление пароля - Школьные олимпиады");
            message.setText(
                    "Здравствуйте!\n\n" +
                            "Вы запросили восстановление пароля для вашего аккаунта.\n\n" +
                            "Для установки нового пароля перейдите по ссылке:\n" +
                            resetLink + "\n\n" +
                            "Ссылка действительна в течение 24 часов.\n\n" +
                            "Если вы не запрашивали восстановление пароля, проигнорируйте это письмо.\n\n" +
                            "С уважением,\n" +
                            "Команда Школьных олимпиад"
            );

            mailSender.send(message);
            System.out.println("✅ Email успешно отправлен на: " + toEmail);
            System.out.println("🔗 Ссылка для сброса: " + resetLink);

        } catch (Exception e) {
            System.err.println("❌ Ошибка отправки email на " + toEmail + ": " + e.getMessage());
            e.printStackTrace();

            // В случае ошибки все равно выводим ссылку в консоль для разработки
            String resetLink = frontendUrl + "/reset-password?token=" + token;
            System.out.println("🔗 Ссылка для сброса (для разработки): " + resetLink);
            System.out.println("📧 Получатель: " + toEmail);

            throw new RuntimeException("Не удалось отправить email: " + e.getMessage());
        }
    }
}

package org.example.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;

import jakarta.annotation.PostConstruct;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class ImageService {

    @Value("${upload.dir}")
    private String uploadDir;

    private Path orderFile;
    private final ObjectMapper objectMapper = new ObjectMapper();

    @PostConstruct
    public void init() {
        try {
            Path uploadPath = Paths.get(uploadDir);
            if (!Files.exists(uploadPath)) {
                Files.createDirectories(uploadPath);
                System.out.println("Created upload directory: " + uploadPath.toAbsolutePath());
            }

            // Файл для хранения порядка изображений
            orderFile = uploadPath.resolve("image_order.json");
            
            // Если файл порядка не существует, создаем пустой список
            if (!Files.exists(orderFile)) {
                saveImageOrder(new ArrayList<>());
            }

            System.out.println("Upload directory is writable: " + uploadDir);
        } catch (IOException e) {
            System.err.println("Could not create upload directory: " + e.getMessage());
            throw new RuntimeException("Could not initialize storage", e);
        }
    }

    public List<String> uploadImages(List<MultipartFile> files) throws IOException {
        List<String> urls = new ArrayList<>();
        List<String> currentOrder = loadImageOrder();
        
        for (MultipartFile file : files) {
            if (file.isEmpty()) {
                continue;
            }
            if (!file.getContentType().startsWith("image/")) {
                throw new IOException("File is not an image: " + file.getOriginalFilename());
            }

            String originalFileName = file.getOriginalFilename();
            String fileExtension = "";
            if (originalFileName != null && originalFileName.contains(".")) {
                fileExtension = originalFileName.substring(originalFileName.lastIndexOf("."));
            }

            String fileName = UUID.randomUUID().toString() + fileExtension;
            Path path = Paths.get(uploadDir + File.separator + fileName);

            System.out.println("Saving file to: " + path.toAbsolutePath());

            Files.copy(file.getInputStream(), path);
            String imageUrl = "/uploads/" + fileName;
            urls.add(imageUrl);
            
            // Добавляем новое изображение в конец списка порядка
            currentOrder.add(imageUrl);
        }
        
        // Сохраняем обновленный порядок
        saveImageOrder(currentOrder);
        
        return urls;
    }

    public List<String> getAllImageUrls() throws IOException {
        List<String> order = loadImageOrder();
        
        // Фильтруем только существующие файлы
        List<String> existingImages = order.stream()
                .filter(url -> {
                    String fileName = extractFileNameFromPath(url);
                    Path filePath = Paths.get(uploadDir + File.separator + fileName);
                    return Files.exists(filePath);
                })
                .collect(Collectors.toList());
        
        // Если порядок изменился (некоторые файлы были удалены вручную), сохраняем исправленный порядок
        if (existingImages.size() != order.size()) {
            saveImageOrder(existingImages);
        }
        
        return existingImages;
    }

    public void deleteImage(String fileName) throws IOException {
        try {
            String cleanFileName = extractFileNameFromPath(fileName);
            Path path = Paths.get(uploadDir + File.separator + cleanFileName);

            System.out.println("Attempting to delete file: " + path.toAbsolutePath());

            if (Files.exists(path)) {
                Files.delete(path);
                System.out.println("File deleted successfully: " + cleanFileName);
                
                // Удаляем изображение из порядка
                List<String> currentOrder = loadImageOrder();
                String imageUrlToRemove = "/uploads/" + cleanFileName;
                currentOrder.remove(imageUrlToRemove);
                saveImageOrder(currentOrder);
                
            } else {
                System.err.println("File not found: " + path.toAbsolutePath());
                throw new IOException("Image not found: " + cleanFileName);
            }
        } catch (Exception e) {
            System.err.println("Error deleting file: " + e.getMessage());
            throw new IOException("Error deleting image: " + e.getMessage(), e);
        }
    }

    public void updateImageOrder(List<String> newOrder) throws IOException {
        // Валидация: проверяем, что все файлы в новом порядке существуют
        for (String imageUrl : newOrder) {
            String fileName = extractFileNameFromPath(imageUrl);
            Path filePath = Paths.get(uploadDir + File.separator + fileName);
            if (!Files.exists(filePath)) {
                throw new IOException("Image not found: " + fileName);
            }
        }
        
        saveImageOrder(newOrder);
    }

    private List<String> loadImageOrder() throws IOException {
        if (!Files.exists(orderFile)) {
            return new ArrayList<>();
        }
        return objectMapper.readValue(orderFile.toFile(), new TypeReference<List<String>>() {});
    }

    private void saveImageOrder(List<String> order) throws IOException {
        objectMapper.writeValue(orderFile.toFile(), order);
    }

    private String extractFileNameFromPath(String filePath) {
        if (filePath == null || filePath.isEmpty()) {
            return filePath;
        }

        if (filePath.contains("/")) {
            return filePath.substring(filePath.lastIndexOf("/") + 1);
        }

        return filePath;
    }
}

package org.example.service;

import org.example.dto.CreateNewsRequest;
import org.example.dto.NewsResponse;
import org.example.entity.News;
import org.example.exception.NewsNotFoundException;
import org.example.repository.NewsRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Transactional
public class NewsService {
    private final NewsRepository newsRepository;

    public NewsService(NewsRepository newsRepository) {
        this.newsRepository = newsRepository;
    }

    public NewsResponse createNews(CreateNewsRequest request) {
        News news = new News();
        news.setTitle(request.getTitle());
        news.setDescription(request.getDescription());
        news.setNewsDate(request.getNewsDate());

        News savedNews = newsRepository.save(news);
        return convertToResponse(savedNews);
    }

    public void deleteNews(Long id) {
        if (!newsRepository.existsById(id)) {
            throw new NewsNotFoundException("News not found with id: " + id);
        }
        newsRepository.deleteById(id);
    }

    @Transactional(readOnly = true)
    public List<NewsResponse> getAllNews() {
        return newsRepository.findByOrderByNewsDateDescCreatedAtDesc()
                .stream()
                .map(this::convertToResponse)
                .collect(Collectors.toList());
    }

    @Transactional(readOnly = true)
    public NewsResponse getNewsById(Long id) {
        News news = newsRepository.findById(id)
                .orElseThrow(() -> new NewsNotFoundException("News not found with id: " + id));
        return convertToResponse(news);
    }

    private NewsResponse convertToResponse(News news) {
        NewsResponse response = new NewsResponse();
        response.setId(news.getId());
        response.setTitle(news.getTitle());
        response.setDescription(news.getDescription());
        response.setNewsDate(news.getNewsDate());
        response.setCreatedAt(news.getCreatedAt());
        return response;
    }
}

package org.example.service;

import org.example.entity.Olympiad;
import org.example.exception.OlympiadNotFoundException;
import org.example.repository.OlympiadRepository;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDate;
import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class OlympiadService {
    private final OlympiadRepository olympiadRepository;

    public OlympiadService(OlympiadRepository olympiadRepository) {
        this.olympiadRepository = olympiadRepository;
    }

    public Olympiad create(String name, LocalDate date, String description) {
        if (olympiadRepository.findByName(name).isPresent()) {
            throw new RuntimeException("Olympiad with name " + name + " already exists");
        }
        Olympiad olympiad = new Olympiad();
        olympiad.setName(name);
        olympiad.setDate(date);
        olympiad.setDescription(description); // Добавлено сохранение описания
        return olympiadRepository.save(olympiad);
    }

    public void deleteByName(String name) {
        Optional<Olympiad> opt = olympiadRepository.findByName(name);
        if (opt.isEmpty()) {
            throw new OlympiadNotFoundException("Olympiad not found with name: " + name);
        }
        Olympiad olympiad = opt.get();
        olympiadRepository.deleteRelationsByOlympiadId(olympiad.getId());
        olympiadRepository.delete(olympiad);
    }

    public List<Olympiad> getAll() {
        return olympiadRepository.findAll();
    }

    public Optional<Olympiad> findByName(String name) {
        return olympiadRepository.findByName(name);
    }
}

package org.example.service;

import org.example.dto.ResetPasswordResponse;
import org.example.entity.PasswordResetToken;
import org.example.entity.User;
import org.example.exception.UserNotFoundException;
import org.example.repository.PasswordResetTokenRepository;
import org.example.repository.UserRepository;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.UUID;

@Service
@Transactional
public class PasswordResetService {
    private final UserRepository userRepository;
    private final PasswordResetTokenRepository tokenRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    private final EmailService emailService;

    @Value("${password.reset.token.expiry.hours:24}")
    private int tokenExpiryHours;

    public PasswordResetService(UserRepository userRepository,
                                PasswordResetTokenRepository tokenRepository,
                                EmailService emailService) {
        this.userRepository = userRepository;
        this.tokenRepository = tokenRepository;
        this.passwordEncoder = new BCryptPasswordEncoder();
        this.emailService = emailService;
    }

    public void initiatePasswordReset(String email) {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("Пользователь с email " + email + " не найден"));

        // Помечаем старые токены как использованные
        tokenRepository.markAllTokensAsUsed(user);

        // Создаем новый токен
        String token = UUID.randomUUID().toString();
        PasswordResetToken resetToken = new PasswordResetToken();
        resetToken.setToken(token);
        resetToken.setUser(user);
        resetToken.setExpiryDate(LocalDateTime.now().plusHours(tokenExpiryHours));
        resetToken.setUsed(false);

        tokenRepository.save(resetToken);

        // Отправляем email с ссылкой для сброса
        emailService.sendPasswordResetEmail(user.getEmail(), token);
    }

    public ResetPasswordResponse resetPassword(String token, String newPassword) {
        PasswordResetToken resetToken = tokenRepository.findByToken(token)
                .orElseThrow(() -> new RuntimeException("Неверный или просроченный токен сброса"));

        if (resetToken.isExpired()) {
            throw new RuntimeException("Срок действия токена истек");
        }

        if (resetToken.getUsed()) {
            throw new RuntimeException("Токен уже был использован");
        }

        // Обновляем пароль пользователя
        User user = resetToken.getUser();
        user.setPassword(passwordEncoder.encode(newPassword));
        userRepository.save(user);

        // Помечаем токен как использованный
        resetToken.setUsed(true);
        tokenRepository.save(resetToken);

        return new ResetPasswordResponse("Пароль успешно изменен", true);
    }

    public boolean validateToken(String token) {
        try {
            PasswordResetToken resetToken = tokenRepository.findByToken(token)
                    .orElseThrow(() -> new RuntimeException("Неверный токен"));

            return !resetToken.isExpired() && !resetToken.getUsed();
        } catch (Exception e) {
            return false;
        }
    }
}

package org.example.service;

import org.example.repository.PasswordResetTokenRepository;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service
public class TokenCleanupService {
    private final PasswordResetTokenRepository tokenRepository;

    public TokenCleanupService(PasswordResetTokenRepository tokenRepository) {
        this.tokenRepository = tokenRepository;
    }

    @Scheduled(cron = "0 0 2 * * ?") // Каждый день в 2:00
    @Transactional
    public void cleanUpExpiredTokens() {
        tokenRepository.deleteExpiredTokens();
        System.out.println("🧹 Запущена очистка просроченных токенов");
    }
}

package org.example.service;

import org.example.dto.AdminProfileResponse;
import org.example.dto.OlympiadResponse;
import org.example.dto.ProfileResponse;
import org.example.dto.ProfileUpdateRequest;
import org.example.dto.RegisterRequest;
import org.example.entity.Olympiad;
import org.example.entity.User;
import org.example.enums.Role;
import org.example.exception.EmailExistsException;
import org.example.exception.OlympiadNotFoundException;
import org.example.exception.UserNotFoundException;
import org.example.repository.UserRepository;
import org.example.util.EncryptionUtil;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@Transactional
public class UserService implements UserDetailsService {
    private final UserRepository userRepository;
    private final EncryptionUtil encryptionUtil;
    private final OlympiadService olympiadService;
    private final BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();

    public UserService(UserRepository userRepository, EncryptionUtil encryptionUtil, OlympiadService olympiadService) {
        this.userRepository = userRepository;
        this.encryptionUtil = encryptionUtil;
        this.olympiadService = olympiadService;
    }

    public User register(RegisterRequest request) {
        Optional<User> existingUser = userRepository.findByEmail(request.getEmail());
        if (existingUser.isPresent()) {
            throw new EmailExistsException("Email already exists: " + request.getEmail());  // Кастомное исключение
        }

        User user = new User();
        user.setEmail(request.getEmail());
        user.setPassword(passwordEncoder.encode(request.getPassword()));

        // Первый пользователь — ADMIN, остальные — USER
        if (userRepository.count() == 0) {
            user.setRole(Role.ADMIN);
        } else {
            user.setRole(Role.USER);
        }

        // Шифруем персональные данные
        user.setLastName(encryptionUtil.encrypt(request.getLastName()));
        user.setFirstName(encryptionUtil.encrypt(request.getFirstName()));
        if (request.getMiddleName() != null) {
            user.setMiddleName(encryptionUtil.encrypt(request.getMiddleName()));
        }
        user.setBirthDate(request.getBirthDate());
        user.setGender(request.getGender());
        user.setClassCourse(request.getClassCourse());
        user.setEducationalInstitution(request.getEducationalInstitution());
        user.setInstitutionAddress(encryptionUtil.encrypt(request.getInstitutionAddress()));
        user.setPhoneNumber(encryptionUtil.encrypt(request.getPhoneNumber()));
        user.setResidenceRegion(encryptionUtil.encrypt(request.getResidenceRegion()));
        user.setResidenceSettlement(encryptionUtil.encrypt(request.getResidenceSettlement()));
        // Устанавливаем значение по умолчанию, если тип населенного пункта не указан
        user.setSettlementType(request.getSettlementType() != null ? request.getSettlementType() : "Не указано");
        user.setSnils(encryptionUtil.encrypt(request.getSnils()));
        user.setPostalAddress(encryptionUtil.encrypt(request.getPostalAddress()));

        return userRepository.save(user);
    }

    public User findByEmail(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new UserNotFoundException("User not found with email: " + email));  // Кастомное
    }

    public void setRole(String email, Role role) {
        User user = findByEmail(email);
        user.setRole(role);
        userRepository.save(user);
    }

    @Override
    public UserDetails loadUserByUsername(String email) throws UsernameNotFoundException {
        User user = userRepository.findByEmail(email)
                .orElseThrow(() -> new UsernameNotFoundException("User not found: " + email));
        return org.springframework.security.core.userdetails.User.builder()
                .username(user.getEmail())
                .password(user.getPassword())
                .roles(user.getRole().name())
                .build();
    }

    public boolean validatePassword(String rawPassword, String encodedPassword) {
        return passwordEncoder.matches(rawPassword, encodedPassword);
    }

    public ProfileResponse getProfileByEmail(String email) {
        User user = findByEmail(email);

        ProfileResponse response = new ProfileResponse();
        response.setId(user.getId());
        response.setEmail(user.getEmail());
        response.setRole(user.getRole());

        // Дешифруем персональные данные
        response.setLastName(encryptionUtil.decrypt(user.getLastName()));
        response.setFirstName(encryptionUtil.decrypt(user.getFirstName()));
        if (user.getMiddleName() != null) {
            response.setMiddleName(encryptionUtil.decrypt(user.getMiddleName()));
        }
        response.setBirthDate(user.getBirthDate());
        response.setGender(user.getGender());
        response.setClassCourse(user.getClassCourse());
        response.setEducationalInstitution(user.getEducationalInstitution());
        response.setInstitutionAddress(encryptionUtil.decrypt(user.getInstitutionAddress()));
        response.setPhoneNumber(encryptionUtil.decrypt(user.getPhoneNumber()));
        response.setResidenceRegion(encryptionUtil.decrypt(user.getResidenceRegion()));
        response.setResidenceSettlement(encryptionUtil.decrypt(user.getResidenceSettlement()));
        response.setSettlementType(user.getSettlementType());
        response.setSnils(encryptionUtil.decrypt(user.getSnils()));
        response.setPostalAddress(encryptionUtil.decrypt(user.getPostalAddress()));
        response.setRegistrationDate(user.getRegistrationDate());

        response.setSelectedOlympiads(user.getOlympiads().stream().map(o -> {
            OlympiadResponse r = new OlympiadResponse();
            r.setName(o.getName());
            r.setDate(o.getDate());
            r.setDescription(o.getDescription());
            return r;
        }).collect(Collectors.toList()));

        return response;
    }

    // Новый метод для админского получения данных (совместим с форматом обновления)
    public AdminProfileResponse getAdminProfileByEmail(String email) {
        User user = findByEmail(email);

        AdminProfileResponse response = new AdminProfileResponse();
        response.setEmail(user.getEmail());

        // Дешифруем персональные данные в том же формате, что принимает update
        response.setLastName(encryptionUtil.decrypt(user.getLastName()));
        response.setFirstName(encryptionUtil.decrypt(user.getFirstName()));
        if (user.getMiddleName() != null) {
            response.setMiddleName(encryptionUtil.decrypt(user.getMiddleName()));
        }
        response.setBirthDate(user.getBirthDate());
        response.setGender(user.getGender());
        response.setClassCourse(user.getClassCourse());
        response.setEducationalInstitution(user.getEducationalInstitution());
        response.setInstitutionAddress(encryptionUtil.decrypt(user.getInstitutionAddress()));
        response.setPhoneNumber(encryptionUtil.decrypt(user.getPhoneNumber()));
        response.setResidenceRegion(encryptionUtil.decrypt(user.getResidenceRegion()));
        response.setResidenceSettlement(encryptionUtil.decrypt(user.getResidenceSettlement()));
        response.setSnils(encryptionUtil.decrypt(user.getSnils()));
        response.setPostalAddress(encryptionUtil.decrypt(user.getPostalAddress()));

        // Добавляем олимпиады для информации (не для редактирования)
        response.setSelectedOlympiads(user.getOlympiads().stream().map(o -> {
            OlympiadResponse r = new OlympiadResponse();
            r.setName(o.getName());
            r.setDate(o.getDate());
            r.setDescription(o.getDescription());
            return r;
        }).collect(Collectors.toList()));

        return response;
    }

    // Обновление профиля (частичное)
    public User updateProfile(String currentEmail, ProfileUpdateRequest request) {
        User user = findByEmail(currentEmail);  // Текущий пользователь

        // Проверяем уникальность email, если изменён
        if (request.getEmail() != null && !request.getEmail().equals(currentEmail)) {
            if (userRepository.findByEmail(request.getEmail()).isPresent()) {
                throw new EmailExistsException("Email already exists: " + request.getEmail());
            }
            user.setEmail(request.getEmail());
        }

        // Обновляем только переданные поля (с шифрованием персональных)
        if (request.getLastName() != null) user.setLastName(encryptionUtil.encrypt(request.getLastName()));
        if (request.getFirstName() != null) user.setFirstName(encryptionUtil.encrypt(request.getFirstName()));
        if (request.getMiddleName() != null) user.setMiddleName(encryptionUtil.encrypt(request.getMiddleName()));
        if (request.getBirthDate() != null) user.setBirthDate(request.getBirthDate());
        if (request.getGender() != null) user.setGender(request.getGender());
        if (request.getClassCourse() != null) user.setClassCourse(request.getClassCourse());
        if (request.getEducationalInstitution() != null) user.setEducationalInstitution(request.getEducationalInstitution());
        if (request.getInstitutionAddress() != null) user.setInstitutionAddress(encryptionUtil.encrypt(request.getInstitutionAddress()));
        if (request.getPhoneNumber() != null) user.setPhoneNumber(encryptionUtil.encrypt(request.getPhoneNumber()));
        if (request.getResidenceRegion() != null) user.setResidenceRegion(encryptionUtil.encrypt(request.getResidenceRegion()));
        if (request.getResidenceSettlement() != null) user.setResidenceSettlement(encryptionUtil.encrypt(request.getResidenceSettlement()));
        if (request.getSnils() != null) user.setSnils(encryptionUtil.encrypt(request.getSnils()));
        if (request.getPostalAddress() != null) user.setPostalAddress(encryptionUtil.encrypt(request.getPostalAddress()));

        return userRepository.save(user);
    }

    public void addOlympiads(String email, List<String> names) {
        User user = findByEmail(email);
        for (String name : names) {
            Optional<Olympiad> opt = olympiadService.findByName(name);
            if (opt.isEmpty()) {
                throw new OlympiadNotFoundException("Olympiad not found: " + name);
            }
            user.getOlympiads().add(opt.get());
        }
        userRepository.save(user);
    }

    public void removeOlympiad(String email, String name) {
        User user = findByEmail(email);
        Optional<Olympiad> opt = olympiadService.findByName(name);
        if (opt.isEmpty()) {
            throw new OlympiadNotFoundException("Olympiad not found: " + name);
        }
        user.getOlympiads().remove(opt.get());
        userRepository.save(user);
    }

    public List<ProfileResponse> getAllUserProfiles() {
        return userRepository.findAll().stream()
                .filter(u -> u.getRole() == Role.USER)
                .map(u -> getProfileByEmail(u.getEmail()))
                .collect(Collectors.toList());
    }

    public void deleteUserByEmail(String email) {
        User user = findByEmail(email);
        // Очищаем связи с олимпиадами перед удалением
        user.getOlympiads().clear();
        userRepository.save(user); // Сохраняем изменения перед удалением
        userRepository.delete(user);
    }

    public User updateUserProfileByAdmin(String targetEmail, ProfileUpdateRequest request) {
        User user = findByEmail(targetEmail);

        // Проверяем уникальность email, если изменён
        if (request.getEmail() != null && !request.getEmail().equals(targetEmail)) {
            if (userRepository.findByEmail(request.getEmail()).isPresent()) {
                throw new EmailExistsException("Email already exists: " + request.getEmail());
            }
            user.setEmail(request.getEmail());
        }

        // Обновляем только переданные поля (с шифрованием персональных)
        if (request.getLastName() != null) user.setLastName(encryptionUtil.encrypt(request.getLastName()));
        if (request.getFirstName() != null) user.setFirstName(encryptionUtil.encrypt(request.getFirstName()));
        if (request.getMiddleName() != null) user.setMiddleName(encryptionUtil.encrypt(request.getMiddleName()));
        if (request.getBirthDate() != null) user.setBirthDate(request.getBirthDate());
        if (request.getGender() != null) user.setGender(request.getGender());
        if (request.getClassCourse() != null) user.setClassCourse(request.getClassCourse());
        if (request.getEducationalInstitution() != null) user.setEducationalInstitution(request.getEducationalInstitution());
        if (request.getInstitutionAddress() != null) user.setInstitutionAddress(encryptionUtil.encrypt(request.getInstitutionAddress()));
        if (request.getPhoneNumber() != null) user.setPhoneNumber(encryptionUtil.encrypt(request.getPhoneNumber()));
        if (request.getResidenceRegion() != null) user.setResidenceRegion(encryptionUtil.encrypt(request.getResidenceRegion()));
        if (request.getResidenceSettlement() != null) user.setResidenceSettlement(encryptionUtil.encrypt(request.getResidenceSettlement()));
        if (request.getSnils() != null) user.setSnils(encryptionUtil.encrypt(request.getSnils()));
        if (request.getPostalAddress() != null) user.setPostalAddress(encryptionUtil.encrypt(request.getPostalAddress()));

        return userRepository.save(user);
    }
}

package org.example.util;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.Cipher;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

@Component
public class EncryptionUtil {
    @Value("${aes.secret}")
    private String aesKey;

    private static final String ALGORITHM = "AES";

    public String encrypt(String data) {
        try {
            // Обрезаем/дополняем ключ до 32 байт (AES-256)
            byte[] keyBytes = aesKey.getBytes(StandardCharsets.UTF_8);
            byte[] fixedKey = new byte[32];
            System.arraycopy(keyBytes, 0, fixedKey, 0, Math.min(keyBytes.length, 32));
            // Дополняем нулями, если короче 32 байт
            for (int i = keyBytes.length; i < 32; i++) {
                fixedKey[i] = 0;
            }

            Cipher cipher = Cipher.getInstance(ALGORITHM);
            SecretKeySpec keySpec = new SecretKeySpec(fixedKey, ALGORITHM);
            cipher.init(Cipher.ENCRYPT_MODE, keySpec);
            byte[] encrypted = cipher.doFinal(data.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(encrypted);
        } catch (Exception e) {
            throw new RuntimeException("Encryption failed", e);
        }
    }

    public String decrypt(String encryptedData) {
        try {
            // Аналогично для decrypt
            byte[] keyBytes = aesKey.getBytes(StandardCharsets.UTF_8);
            byte[] fixedKey = new byte[32];
            System.arraycopy(keyBytes, 0, fixedKey, 0, Math.min(keyBytes.length, 32));
            for (int i = keyBytes.length; i < 32; i++) {
                fixedKey[i] = 0;
            }

            Cipher cipher = Cipher.getInstance(ALGORITHM);
            SecretKeySpec keySpec = new SecretKeySpec(fixedKey, ALGORITHM);
            cipher.init(Cipher.DECRYPT_MODE, keySpec);
            byte[] decoded = Base64.getDecoder().decode(encryptedData);
            byte[] decrypted = cipher.doFinal(decoded);
            return new String(decrypted, StandardCharsets.UTF_8);
        } catch (Exception e) {
            throw new RuntimeException("Decryption failed", e);
        }
    }
}

package org.example.util;

import org.example.enums.Role;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import io.jsonwebtoken.security.Keys;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import javax.crypto.SecretKey;
import java.util.Date;

@Component
public class JwtUtil {
    @Value("${jwt.secret}")
    private String secretKey;

    private static final long EXPIRATION_TIME = 2592000000L; // 30 дней

    public String generateToken(String email, Role role) {
        SecretKey key = Keys.hmacShaKeyFor(secretKey.getBytes());
        return Jwts.builder()
                .setSubject(email)
                .claim("role", role.name())
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .signWith(key, SignatureAlgorithm.HS512)
                .compact();
    }

    public String extractEmail(String token) {
        SecretKey key = Keys.hmacShaKeyFor(secretKey.getBytes());
        Claims claims = Jwts.parser()
                .setSigningKey(key)
                .build()
                .parseSignedClaims(token)
                .getBody();
        return claims.getSubject();
    }

    public Role extractRole(String token) {
        SecretKey key = Keys.hmacShaKeyFor(secretKey.getBytes());
        Claims claims = Jwts.parser()
                .setSigningKey(key)
                .build()
                .parseSignedClaims(token)
                .getBody();
        return Role.valueOf(claims.get("role", String.class));
    }

    public boolean isTokenValid(String token, String email) {
        return (email.equals(extractEmail(token)) && !isTokenExpired(token));
    }

    private boolean isTokenExpired(String token) {
        SecretKey key = Keys.hmacShaKeyFor(secretKey.getBytes());
        return Jwts.parser()
                .setSigningKey(key)
                .build()
                .parseSignedClaims(token)
                .getBody()
                .getExpiration()
                .before(new Date());
    }
}

# PostgreSQL
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Server
server.port=8300

# Swagger
springdoc.api-docs.path=/v3/api-docs
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.swagger-ui.enabled=true

# File upload configuration
upload.dir=./uploads
spring.servlet.multipart.enabled=true
spring.servlet.multipart.max-file-size=10MB
spring.servlet.multipart.max-request-size=50MB

# Create upload directory automatically
spring.web.resources.static-locations=classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/,file:./uploads/

# Email Configuration ??? Mail.ru
spring.mail.host=smtp.mail.ru
spring.mail.port=465
spring.mail.username=${SPRING_MAIL_USERNAME}
spring.mail.password=${SPRING_MAIL_PASSWORD}
spring.mail.protocol=smtps
spring.mail.properties.mail.smtp.auth=true
spring.mail.properties.mail.smtp.ssl.enable=true
spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory
spring.mail.properties.mail.smtp.socketFactory.port=465
spring.mail.properties.mail.smtp.connectiontimeout=5000
spring.mail.properties.mail.smtp.timeout=5000
spring.mail.properties.mail.smtp.writetimeout=5000

# Password Reset
password.reset.token.expiry.hours=24
app.frontend.url=${SPRING_RESET_PASSWORD_URL}


